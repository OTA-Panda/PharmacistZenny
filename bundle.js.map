{"version":3,"sources":["webpack/bootstrap","./src/zenny.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","canvas","document","getElementById","context","getContext","scale","bottleCreate","width","height","matrix","push","Array","fill","bottle","console","log","table","bottleOffset","bottleSpout","bottleNew","forEach","row","player","score","playerScore","bottleClearSection","positionsArray","length","x","y","bottleCheck","consecutive","allMatchPositions","verticalPositions","concat","horizontalPositions","pillColor","colors","Math","random","pillCreate","pos","pill","draw","fillStyle","fillRect","drawMatrix","offset","_merge","_collide","dropCounter","lastTime","pillNew","pillDrop","gameLoop","time","deltaTime","requestAnimationFrame","playerMove","dir","pillRotate","reverse","playerRotate","innerText","addEventListener","event","code"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const canvas = document.getElementById('zenny')\nconst context = canvas.getContext('2d')\n\nconst scaleUp = 20\n//multiplies 1px by scaleUp to x, y\ncontext.scale(scaleUp, scaleUp)\n\n//pushes an array of length 'width' with each element as 0\n//into array 'matrix,' decrementing 'height' until falsey (i.e. 0)\nbottleCreate = (width, height) => {\n  const matrix = []\n  while (height--) matrix.push(new Array(width).fill(0))\n  return matrix\n}\n\n//instantiate logical 2d field with 8 columns and 16 rows filled with 0s\nconst bottle = bottleCreate(8, 16)\nconsole.log(bottle); console.table(bottle)\n\n//offsets for moving graphics and logic\nconst bottleOffset = { x: 3, y: 3 }\n\n//position of spout on bottle\nconst bottleSpout = { x: 3, y: 0 }\n\nbottleNew = () => {\n  bottle.forEach(row => row.fill(0))\n  player.score = 0\n  playerScore()\n}\n\nbottleClearSection = (positionsArray) => {\n  for (let i = 0; i < positionsArray.length; i++) {\n    const x = positionsArray[i][0]\n    const y = positionsArray[i][1]\n    bottle[y][x] = 0\n    player.score += 10\n  }\n}\n\nbottleCheck = () => {\n  let consecutive = 1\n  let allMatchPositions = []\n\n  for (let x = 0; x < bottle[0].length  ; ++x) {\n    let verticalPositions = []\n    for (let y = bottle.length - 1; y > 0; --y) {\n      if (bottle[y][x] && bottle[y + 1] && bottle[y][x] === bottle[y + 1][x]) {\n        if (consecutive === 1) verticalPositions.push([x, y + 1])\n        consecutive++\n        console.log(consecutive)\n        verticalPositions.push([x, y])\n      } else {\n        if (consecutive > 3) {\n          console.log(\"4 chain!\")\n          console.log(verticalPositions)\n          allMatchPositions = allMatchPositions.concat(verticalPositions)\n          console.log(allMatchPositions)\n        }\n        consecutive = 1\n        verticalPositions = []\n      }\n      //if at top of column, check consecutive and remove items if great than 3\n      if (y === 0 && consecutive > 3) {\n        console.log(\"4 chain!\")\n        console.log(verticalPositions)\n        allMatchPositions = allMatchPositions.concat(verticalPositions)\n      }\n    }\n  }\n\n  for (let y = bottle.length - 1; y > 0; --y) {  //14 to check only first row\n    let horizontalPositions = []\n    for (let x = 0; x < bottle[y].length; ++x) {\n      if (bottle[y][x] && bottle[y][x - 1] && bottle[y][x] === bottle[y][x - 1]) {\n        if (consecutive === 1) horizontalPositions.push([x - 1, y])\n        consecutive++\n        horizontalPositions.push([x, y])\n      } else {\n        if (consecutive > 3) {\n          console.log(\"4 chain!\")\n          console.log(horizontalPositions)\n          allMatchPositions = allMatchPositions.concat(horizontalPositions)\n        }\n        consecutive = 1\n        horizontalPositions = []\n      }\n      //if at end of row, check consecutive and remove items if great than 3\n      if (x === bottle[y].length - 1 && consecutive > 3) {\n        console.log(\"4 chain!\")\n        console.log(horizontalPositions)\n        allMatchPositions = allMatchPositions.concat(horizontalPositions)\n      }\n      // console.log(`${bottle[y][x]} ${consecutive}`)\n    }\n  }\n  bottleClearSection(allMatchPositions)\n}\n\npillColor = () => {\n  const colors = ['red', 'yellow', 'blue']\n  return colors[Math.random() * colors.length | 0]\n}\n\npillCreate = () => {\n  const c1 = pillColor()\n  const c2 = pillColor()\n  return [\n    [c1, 0],\n    [c2, 0]\n  ]\n}\n\n//paramaters of player's pill and its logical shape, orientation, and position\nconst player = { \n  pos: { x: bottleSpout.x, y: bottleSpout.y }, //starting position of pill\n  pill: pillCreate(),\n  score: 0,\n}\n\ndraw = () => {\n  context.fillStyle = '#000' //black\n  context.fillRect(0, 0, canvas.width, canvas.height) //background based on index.html\n  context.fillStyle = '#55f' //blue\n  context.fillRect(0 + bottleOffset.x, 0 + bottleOffset.y, 8, 16) //bottle\n  context.fillStyle = '#55f' //blue\n  context.fillRect(\n    bottleSpout.x + bottleOffset.x,\n    bottleSpout.y + bottleOffset.y - 1,\n    2, 1) //spout\n  drawMatrix(bottle, { x: 0, y: 0}) //draw any spaces that exist in logic\n  drawMatrix(player.pill, player.pos) //draws shape based on position\n}\n\n\n//function that renders pill based on matrix and offset given\ndrawMatrix = (matrix, offset) => {\n  matrix.forEach((row, y) => {\n    row.forEach((value, x) => {\n      if (value !== 0) {\n        context.fillStyle = value\n        context.fillRect(\n          x + offset.x + bottleOffset.x, //position x\n          y + offset.y + bottleOffset.y, //position y\n          1, //1 unit(px) wide\n          1  //1 unit(px) high\n        )\n      }\n    })\n  })\n}\n\n//logical merge of pill matrix to bottle matrix\n_merge = (bottle, player) => {\n  player.pill.forEach((row, y) => {\n    row.forEach((value, x) => {\n      if (value !== 0) {   //if value in pill matrix exists\n        bottle[y + player.pos.y][x + player.pos.x] = value //overwrite bottle\n      }\n    })\n  })\n}\n\n// drape over bottle and check if player's piece collides\n_collide = (bottle, player) => {\n  const [pill, offset] = [player.pill, player.pos]\n  for (let y = 0; y < pill.length; ++y) { //add y first to check next pos\n    for (let x = 0; x < pill[y].length; ++x) { //add x first to check next pos\n      if (\n        pill[y][x] !== 0 && // if pill shape exists in space...\n        (\n          bottle[y + offset.y] && // check if bottle row exists then...\n          bottle[y + offset.y][x + offset.x] // check if collumn exists...\n        ) !== 0 //if row and column exist, check if space is occupied\n      ) {\n        return true // if all conditions pass, collision is true\n      }\n    }\n  }\n  return false // else collision is false\n}\n\nlet dropCounter = 0\nlet dropInterval = 500 // 1000ms = 1s\nlet lastTime = 0 \n\npillNew = () => {\n  player.pill = pillCreate()\n  player.pos = {x: bottleSpout.x, y: bottleSpout.y}\n  if (_collide(bottle, player)) bottleNew()\n}\n\npillDrop = () => {\n  player.pos.y++\n  if (_collide(bottle, player)) {\n    player.pos.y--\n    _merge(bottle, player)\n    bottleCheck(bottle)\n    pillNew()\n    playerScore()\n    // console.table(bottle)\n  }\n  dropCounter = 0  //reset counter\n}\n\n//Define Game Loop\ngameLoop = (time = 0) => {\n  const deltaTime = time - lastTime //change in time\n  lastTime = time //roughly 16.7ms\n\n  //update player position in bottle on y value\n  //whenever dropCounter is greater than 1s\n  dropCounter += deltaTime\n  if (dropCounter > dropInterval) {\n    pillDrop()\n  }\n  // console.log(deltaTime)\n  draw() //draw or rather re-draw\n  requestAnimationFrame(gameLoop) //recursive loop -- never ends\n}\n\n// moves player in desired direction, but stops if collision is true\nplayerMove = (dir) => {\n  player.pos.x += dir\n  if (_collide(bottle, player)) {\n    player.pos.x -= dir\n  }\n}\n\npillRotate = (matrix, dir) => {  //***NEED TO FIX\n  // console.table(matrix)\n  for (let y = 0; y < matrix.length; ++y) {\n    for (let x = 0; x < y; ++x) {\n      [\n        matrix[x][y],\n        matrix[y][x]\n      ] = [          //flips 2d array along 135 deg axis; everything backwards\n        matrix[y][x],\n        matrix[x][y]\n      ]\n    }\n  }\n  if (dir > 0) {\n    matrix.forEach(row => row.reverse())\n  } else {\n    matrix.reverse()\n  }\n}\n\nplayerRotate = (dir) => {\n  const pos = player.pos.x\n  let offset = -1\n  pillRotate(player.pill, dir)\n  while (_collide(bottle, player)) {\n    player.pos.x += offset\n    offset = -(offset + (offset > 0 ? 1 : -1))\n    if (offset > player.pill[0].length) {\n      pillRotate(player.pill, -dir)\n      player.pos.x = pos\n      return\n    }\n  }\n}\n\nplayerScore = () => {\n  document.getElementById('score').innerText = player.score\n}\n\n//User Interface\ndocument.addEventListener('keydown', event => {\n  // console.log(event)\n  switch (event.code) {\n    case \"ArrowLeft\":  // move pill left\n      playerMove(-1)\n      break\n    case \"ArrowRight\": // move pill right\n      playerMove(+1)\n      break\n    case \"ArrowDown\":  // move pill down : accelerate\n      pillDrop()\n      break\n    case \"KeyD\":       // pillRotate counter-clockwise\n      playerRotate(-1)\n      break\n    case \"KeyF\":       // pillRotate clockwise\n      playerRotate(1)\n      break\n    case \"Space\": //to be used for instant drop\n      break\n  }\n})\n\nplayerScore() //bootstrap score\ngameLoop() //instantiates game loop"],"sourceRoot":""}